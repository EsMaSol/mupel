#!/bin/bash -e
###############################################################################
#                                                                             #
#     Copyright (C) 2015 Team KODI                                            #
#     http://kodi.tv                                                          #
#                                                                             #
#  This program is free software: you can redistribute it and/or modify       #
#  it under the terms of the GNU General Public License as published by       #
#  the Free Software Foundation, either version 3 of the License, or          #
#  (at your option) any later version.                                        #
#                                                                             #
#  This program is distributed in the hope that it will be useful,            #
#  but WITHOUT ANY WARRANTY; without even the implied warranty of             #
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              #
#  GNU General Public License for more details.                               #
#                                                                             #
#  You should have received a copy of the GNU General Public License          #
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.      #
#                                                                             #
###############################################################################

BASE_PATH=${BASE_PATH:-$(cd $(dirname $0)/../.. ; pwd -P)}

. "$HOME/.mupel/mupel.conf"
. "$BASE_PATH/tools/tool_functions"
. "$BASE_PATH/tools/tool_install_functions"

# To store needed cpu bit size, e.g. defined from script options or if not
# set selected from user.
# Only be used on 64bit systems
arch=
alt_repos=
distname=
main_msg=

function usage() {
  echo "usage: ${0##*/} [-m mirror] [-g group,...] [-s] [-c] [-t bits] [-d distname] [-u]"
  echo "-b dir       additional directories that should be bind mounted,"
  echo '             or "NONE".'
  echo "             Default: if local filesystems present, ask user for help"
  echo "-g group,... groups that can use the chroot unauthenticated"
  echo "             Default: '${admin}' and current user's group ('$(id -gn)')"
  echo "-m mirror    an alternate repository mirror for package downloads"
  echo "-s           configure default deb-srcs"
  echo "-l file      store log messages"
  echo "-c           always copy 64bit helper binaries to 32bit chroot"
  echo "-t bits      bit size of used CPU, allowed are '32' or '64', usable only"
  echo "             on 64 bit system"
  echo "-d distname  distribution name to use for chromium, usable here are"
  echo "             'precise' and 'utopic', more are available and possible"
  echo "             to select by hand if value left empty"
  echo "-u           to add updates and security to the chroot's sources.list"
  echo "-n           no install of build dependencies now"
  echo "-f           if set install is related to a flow and several messages becomes not used"
  echo "-h           this help message"
}

function process_opts()
{
  local OPTNAME OPTIND OPTERR OPTARG
  while getopts ":b:g:l:m:scht:d:unf" OPTNAME; do
  {
    case "$OPTNAME" in
      b)
        if [ "${OPTARG}" = "NONE" ] && [ -z "${bind_mounts}" ];then
          bind_mounts="${OPTARG}"
        else
        {
          if [ "${bind_mounts}" = "NONE" ] || [ "${OPTARG}" = "${OPTARG#/}" ] || [ ! -d "${OPTARG}" ];then
          {
            echo "Invalid -b option(s)"
            usage
            exit 1
          } fi
          bind_mounts="${bind_mounts}
${OPTARG} ${OPTARG} none rw,bind 0 0"
        } fi
        ;;
      l)
        main_msg="$OPTARG"
        ;;
      g)
        [ -n "${OPTARG}" ] &&
          chroot_groups="${chroot_groups}${chroot_groups:+,}${OPTARG}"
        ;;
      m)
        if [ -n "${mirror}" ];then
        {
          echo "You can only specify exactly one mirror location"
          usage
          exit 1
        } fi
        mirror="$OPTARG"
        ;;
      s)
        add_srcs="y"
        ;;
      c)
        copy_64="y"
        ;;
      t)
        if [ "${OPTARG}" == 32 -o "${OPTARG}" == 64 ];then
          arch="${OPTARG}bit"
        else
        {
          echo "Invalid -t option"
          usage
        } fi
        ;;
      d)
        distname="$OPTARG"
        ;;
      u)
        alt_repos="y"
        ;;
      n)
        no_install_build_deps="y"
        ;;
      f)
        full_install_flow="y"
        ;;
      h)
        usage
        exit 0
        ;;
      \:)
        echo "'-$OPTARG' needs an argument."
        usage
        exit 1
        ;;
      *)
        echo "invalid command-line option: $OPTARG"
        usage
        exit 1
        ;;
    esac
  } done

  if [ $# -ge ${OPTIND} ];then
  {
    eval echo "Unexpected command line argument: \${${OPTIND}}"
    usage
    exit 1
  } fi
}

function exit_build()
{
  local ret=$1
  rm -rf $TEMP_DIR
  exit $ret
}

###-------------------------------------------------------------------------###
#                                                                             #
#                            Start of process points                          #
#                                                                             #

DIST=`grep DISTRIB_ID /etc/*-release | awk -F '=' '{print $2}'`
[ $DIST != "Ubuntu" ] && [ $DIST != "Debian" ] && {
  echo "${RED}${BRIGHT}Build not possible, need performed on ubuntu or debian based system (needed for install of dependencies parts)${NORMAL}" >&2;
  exit 1 ;
}

# Check that xserver is running and user is root.
[[ $DISPLAY ]] || {
  echo $"${RED}${BRIGHT}There is no xserver running. Exiting...${NORMAL}";
  exit 1;
}

[[ `uname -m` != "x86_64" ]] && {
  echo $"${RED}${BRIGHT}Wrong system, a 64 bit linux OS is needed!${NORMAL}";
  exit_build 1
}

# Check that we are running as a regular user
[ "$(id -nu)" = root ] && {
  printf "${RED}${BRIGHT}Run this script as a regular user and provide your \"sudo\" password if requested!${NORMAL}\n" >&2;
  exit 1;
}

process_opts "$@"

TEMP_DIR=`mktemp -d`
main_msg_tmp=${TEMP_DIR}/install.log
build_log=./build/install.log
touch $build_log

###
# Check for missing packages
#
packages=""

if [ "${packages}" != "" ];then
  cat > ${TEMP_DIR}/build-dep-install.sh << EOF
#!/bin/bash

printf "Installing of build dependencies \"$packages\" is needed!\n\n"

sudo -A -- apt-get -y install ${packages}
EOF
  chmod +x ${TEMP_DIR}/build-dep-install.sh

  run_in_terminal ${TEMP_DIR}/build-dep-install.sh
  if [ $? != 0 ];then
    echo "Install of build dependencies failed"
    exit_build 1
  fi
fi

[ -z $main_msg ] && main_msg=/dev/stdout

showInfoDialog "
  chroot based Ubuntu distribution creator
_________________________________________________________________________________________

  This script will help you through the process of installing a
  Debian or Ubuntu distribution in a chroot environment. You will
  have to provide your \"sudo\" password when requested.
" 5

# Error handler
trap 'evaluate_ret_error 1; exit_build 1' INT TERM QUIT HUP
trap 'sudo -A -- apt-get clean; tput bel; echo; echo Failed' EXIT

{
  touch "${main_msg}"
  (
    touch "${TEMP_DIR}/build_active"
    # Install any missing applications that this script relies on. If these packages
    # are already installed, don't force another "apt-get install". That would
    # prevent them from being auto-removed, if they ever become eligible for that.
    # And as this script only needs the packages once, there is no good reason to
    # introduce a hard dependency on things such as dchroot and debootstrap.
    dep=
    for i in dchroot debootstrap libwww-perl; do
      [ -d /usr/share/doc/"$i" ] || dep="$dep $i"
    done

    sudo -A -- apt-get -y install $dep schroot;
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1

    rm -f "${TEMP_DIR}/build_active";
    sleep 5;
    exit 0;
  ) | sed -u "s/.*/# &/ w ${main_msg_tmp}" >> ${main_msg} &
  pid=$!
}
{
  tail -f --pid=$pid ${main_msg} |
    showdialog --title="Update" --image="$BASE_PATH/icons/icon-install-128x128.png" --progress \
               --width=600 \
               --text="Install any missing applications" \
               --pulsate --enable-log --log-height=300 --button=gtk-cancel:1 \
               --auto-close > /dev/null
  ret=$?
  cat $main_msg_tmp >> $build_log
  if [[ $ret != 0 ]];then
  {
    showErrorDialog "Installation cancelled.\nExiting"
    ps -p $pid
    [[ $? = 0 ]] && killtree $pid KILL
    rm -f "${TEMP_DIR}/build_active"
    exit_build 1
  }
  elif [ -f "${TEMP_DIR}/build_active" ];then
  {
    showErrorDialog "Installation failed.\nExiting"
    rm -f "${TEMP_DIR}/build_active"
    exit_build 1
  } fi
}

# Create directory for chroot
sudo -A -- mkdir -p /var/lib/chroot

if [ -z $distname ];then
{
  # Find chroot environments that can be installed with debootstrap
  targets="$(cd /usr/share/debootstrap/scripts
             ls | grep '^[a-z]*$')"

  # Ask user to pick one of the available targets
  for i in $targets; do
    targets=`printf "$targets %s" "$i"`;done

  while :; do
  {
    distname=$(showdialog --list \
                          --text="The following targets are available to be installed in a chroot:" \
                          --radiolist \
                          --column "Use" \
                          --column "Type" \
                          --print-column=2 \
                          $targets \
                          --width=400 --height=390 2> /dev/null)
    distname=${distname%|};
    if [ -z $distname ];then
    {
      showWarningDialog_YesNo "No ditribution selected! \n\nTry again?"
      [ $? != 0 ] && exit_build 1
    }
    else
      break;fi
  } done
} fi

# On x86-64, ask whether the user wants to install x86-32 or x86-64
archflag=
if [ "$(uname -m)" = x86_64 ];then
{
  if [ -z $arch ];then
  {
    while :; do
    {
      arch=$(showdialog --list \
                        --text="\
  You are running a 64bit kernel. This allows you to install either a
  32bit or a 64bit chroot environment.
  Which one do you want (32bit or 64bit)?" \
                        --radiolist \
                        --column "Use" \
                        --column "Type" \
                          FALSE "32bit" \
                          FALSE "64bit" \
                        --print-column=2 \
                        --width=400 --height=390 2> /dev/null)
      arch=${arch%|};
      if [ -z $arch ];then
      {
        showWarningDialog_YesNo "You must select the used architecture! \n\nTry again?"
        [ $? != 0 ] && exit_build 1
      }
      else
        break;fi
    } done
  }
  else
    showInfoDialog "You are running a 64bit kernel and ${arch} selected from options" 2;fi

  [ "${arch}" == "32bit" ] && archflag="--arch i386" || archflag="--arch amd64"
} fi

target="${distname}${arch}"

# Don't accidentally overwrite an existing installation
[ -d /var/lib/chroot/"${target}" ] && {
  while :; do
    label="This chroot \"${target%bit}\" already exists on your machine."
    if schroot -l --all-sessions 2>&1 |
       sed 's/^session://' |
       grep -qs "^${target}-"; then
      label="$label

And it appears to be in active use. Terminate all programs that
are currently using the chroot environment and then re-run this
script.

If you still get an error message, you might have stale mounts
that you forgot to delete. You can always clean up mounts by
executing \"${target%bit} -c\".

If removed continue with yes, no cancel build."
      showQuestionDialog "$label"
      [ $? != 0 ] && exit_build 1
      continue
    fi

    label="$label

What would you like to do?"
    choice=$(showdialog --list \
                        --title="Question for \"${target}\"" \
                        --image="$BASE_PATH/icons/icon-question-128x128.png" \
                        --text="$label" \
                        --radiolist \
                        --column "Use" \
                        --column "Type" FALSE "Abort" FALSE "Overwrite" FALSE "Delete" \
                        --print-column=2 \
                        --width=400 --height=390 2> /dev/null)
    [ $? != 0 ] && exit_build 1
    case "${choice}" in
      "Abort|")
           exit_build 1;;
      "Overwrite|")
           sudo -A -- rm -rf /var/lib/chroot/${target};
           break;;
      "Delete|")
           sudo -A -- rm -rf /var/lib/chroot/${target}      \
                             /usr/local/bin/${target%bit}   \
                             /etc/schroot/mount-${target}   \
                             /etc/schroot/script-${target}  \
                             /etc/schroot/${target}
           sudo -A -- sed -ni '/^[[]'"${target%bit}"']$/,${
                               :1;n;/^[[]/b2;b1;:2;p;n;b2};p' \
                             "/etc/schroot/schroot.conf"
           trap '' INT TERM QUIT HUP
           trap '' EXIT
           showInfoDialog "\"${target%bit}\" deleted"
           [ -z $full_install_flow ] && exit_build 0
           exit_build 1;;
    esac
  done
}
sudo -A -- mkdir -p /var/lib/chroot/${target}

# Offer to include additional standard repositories for Ubuntu-based chroots.
if [ ! -z "${alt_repos}" ];then
{
  grep -qs ubuntu.com /usr/share/debootstrap/scripts/"${distname}" && {
    showQuestionDialog "Would you like to add ${distname}-updates and ${distname}-security\nto the chroot's sources.list for \"${target%bit}\""
    [ $? = 0 ] && alt_repos=y
  }
} fi

# Check for non-standard file system mount points and ask the user whether
# they should be imported into the chroot environment
# We limit to the first 26 mount points that much some basic heuristics,
# because a) that allows us to enumerate choices with a single character,
# and b) if we find more than 26 mount points, then these are probably
# false-positives and something is very unusual about the system's
# configuration. No need to spam the user with even more information that
# is likely completely irrelevant.
mounts="$(awk '$2 != "/" && $2 !~ "^/boot" && $2 !~ "^/home" &&
               $2 !~ "^/media" && $2 !~ "^/run" &&
               ($3 ~ "ext[2-4]" || $3 == "reiserfs" || $3 == "btrfs" ||
               $3 == "xfs" || $3 == "jfs" || $3 == "u?msdos" ||
               $3 == "v?fat" || $3 == "hfs" || $3 == "ntfs" ||
               $3 ~ "nfs[4-9]?" || $3 == "smbfs" || $3 == "cifs") {
                 print $2
               }' /proc/mounts |
          head -n26)"
if [ -n "${mounts}" ]; then
  targets=
  for i in $mounts; do
    targets=`printf "$targets OFF %s" "$i"`
  done
  mounts=$(showdialog --list --checklist \
                      --text="\
You appear to have non-standard mount points that you
might want to import into the chroot environment.

Select mount points that you want to be included or
ignore for \"${target%bit}\"" \
                      --column "Use" \
                      --column "Point" $targets \
                      --print-column=2 \
                      --width=400 --height=390 2> /dev/null)
fi
IFS=$'|\n'; for m in ${mounts}; do
  bind_mounts="${bind_mounts}$m $m none rw,bind 0 0
"
done
unset IFS
{
  touch "${main_msg}"
  (
    touch "${TEMP_DIR}/build_active"
    printf "\n# ------ Install of \"${distname}\" for ${arch} started ------\n"

    # Remove stale entry from /etc/schroot/schroot.conf. Entries start
    # with the target name in square brackets, followed by an arbitrary
    # number of lines. The entry stops when either the end of file has
    # been reached, or when the beginning of a new target is encountered.
    # This means, we cannot easily match for a range of lines in
    # "sed". Instead, we actually have to iterate over each line and check
    # whether it is the beginning of a new entry.
    sudo -A -- sed -ni '/^[[]'"${target%bit}"']$/,${:1;n;/^[[]/b2;b1;:2;p;n;b2};p' /etc/schroot/schroot.conf

    # Download base system. This takes some time
    if [ -z "${mirror}" ]; then
    {
      grep -qs ubuntu.com /usr/share/debootstrap/scripts/"${distname}" &&
        mirror="http://archive.ubuntu.com/ubuntu" ||
        mirror="http://ftp.us.debian.org/debian"
      err=$?; [ $err != 0 ] && showErrorDialog "Download base system failed, Error code: $err" && exit_build 1
    }
    fi

    # Load basic distribution parts
    sudo -A -- ${http_proxy:+http_proxy="${http_proxy}"} debootstrap ${archflag} "${distname}" "/var/lib/chroot/${target}"  "$mirror" > "/dev/stdout" 2>&1
    err=$?; [ $err != 0 ] && showErrorDialog "Load basic distribution parts failed, Error code: $err" && exit_build 1

    # Add new entry to /etc/schroot/schroot.conf
    grep -qs ubuntu.com /usr/share/debootstrap/scripts/"${distname}" &&
      brand="Ubuntu" || brand="Debian"

    if [ -z "${chroot_groups}" ];then
      chroot_groups="${admin},$(id -gn)";fi

    if [ -d '/etc/schroot/default' ]; then
      new_version=1
      fstab="/etc/schroot/${target}/fstab"
    else
      new_version=0
      fstab="/etc/schroot/mount-${target}"
    fi

    if [ "$new_version" = "1" ]; then
      sudo -A -- cp -ar /etc/schroot/default /etc/schroot/${target};
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
      sudo -A -- sh -c 'cat >>/etc/schroot/schroot.conf' <<EOF
[${target%bit}]
description=${brand} ${distname} ${arch}
type=directory
directory=/var/lib/chroot/${target}
users=root
groups=${chroot_groups}
root-groups=${chroot_groups}
personality=linux$([ "${arch}" != 64bit ] && echo 32)
profile=${target}

EOF
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1

      [ -n "${bind_mounts}" -a "${bind_mounts}" != "NONE" ] &&
        printf "${bind_mounts}" |
          sudo -A -- sh -c 'cat >>'"${fstab}"
    else
      # Older versions of schroot wanted a "priority=" line, whereas recent
      # versions deprecate "priority=" and warn if they see it. We don't have
      # a good feature test, but scanning for the string "priority=" in the
      # existing "schroot.conf" file is a good indication of what to do.
      priority=$(grep -qs 'priority=' /etc/schroot/schroot.conf && echo 'priority=3' || :)
      sudo -A -- "bash -c 'cat >>/etc/schroot/schroot.conf'" << 'EOF'
[${target%bit}]
description=${brand} ${distname} ${arch}bit
type=directory
directory=/var/lib/chroot/${target}
users=root
groups=${chroot_groups}
root-groups=${chroot_groups}
personality=linux$([ "${arch}" != 64bit ] && echo 32)
script-config=script-${target}
${priority}

EOF

      # Set up a list of mount points that is specific to this chroot environment.
      sed '/^FSTAB=/s,"[^"]*","/etc/schroot/mount-'"${target}"'",' \
        /etc/schroot/script-defaults | sudo -A -- sh -c 'cat > /etc/schroot/script-'"${target}"
      sed '\,^/home[/[:space:]],s/\([,[:space:]]\)bind[[:space:]]/\1rbind /' \
        /etc/schroot/mount-defaults | sudo -A -- sh -c 'cat > /etc/schroot/mount-'"${target}"
    fi

    # Add the extra mount points that the user told us about
    [ -n "${bind_mounts}" -a "${bind_mounts}" != "NONE" ] &&
      printf "${bind_mounts}" | sudo -A -- sh -c 'cat >>'"${fstab}"

    # If this system has a \"/media\" mountpoint, import it into the chroot
    # environment. Most modern distributions use this mount point to
    # automatically mount devices such as CDROMs, USB sticks, etc...
    if [ -d /media ] && ! grep -qs '^/media' "${fstab}";then
      echo '/media /media none rw,rbind 0 0' | sudo -A -- sh -c 'cat >>'"${fstab}";fi

    # Share /dev/shm, /run and /run/shm.
    grep -qs '^/dev/shm' "${fstab}" ||
      echo '/dev/shm /dev/shm none rw,bind 0 0' |
        sudo -A -- sh -c 'cat >>'"${fstab}"
    if [ ! -d "/var/lib/chroot/${target}/run" ] && ! grep -qs '^/run' "${fstab}";then
      echo '/run /run none rw,bind 0 0' | sudo -A -- sh -c 'cat >>'"${fstab}";fi
    if ! grep -qs '^/run/shm' "${fstab}";then
    {
      { [ -d /run ] && echo '/run/shm /run/shm none rw,bind 0 0' ||
                       echo '/dev/shm /run/shm none rw,bind 0 0'; } |
        sudo -A -- sh -c 'cat >>'"${fstab}"
    } fi

    grep -qs '^/run/user/1000' "${fstab}" ||
      echo '/run/user/1000  /run/user/1000  none    rw,bind         0       0' | sudo -A -- sh -c 'cat >>'"${fstab}";

    # Install a helper script to launch commands in the chroot
    sudo -A -- sh -c 'cat > /usr/local/bin/'"${target%bit}" << EOF
#!/bin/bash

export SUDO_ASKPASS="$BASE_PATH/tools/sudo-askpass"
EOF
    sudo -A -- sh -c 'cat >> /usr/local/bin/'"${target%bit}" << 'EOF'
chroot="${0##*/}"

wrap()
{
  # Word-wrap the text passed-in on stdin. Optionally, on continuation lines
  # insert the same number of spaces as the number of characters in the
  # parameter(s) passed to this function.
  # If the "fold" program cannot be found, or if the actual width of the
  # terminal cannot be determined, this function doesn't attempt to do any
  # wrapping.
  local f="$(type -P fold)"
  [ -z "${f}" ] && { cat; return; }
  local c="$(stty -a </dev/tty 2>/dev/null |
             sed 's/.*columns[[:space:]]*\([0-9]*\).*/\1/;t;d')"
  [ -z "${c}" ] && { cat; return; }
  local i="$(echo "$*"|sed 's/./ /g')"
  local j="$(printf %s "${i}"|wc -c)"
  if [ "${c}" -gt "${j}" ]; then
    dd bs=1 count="${j}" 2>/dev/null
    "${f}" -sw "$((${c}-${j}))" | sed '2,$s/^/'"${i}"'/'
  else
    "${f}" -sw "${c}"
  fi
}

help() {
  echo "Usage ${0##*/} [-h|--help] [-c|--clean] [-C|--clean-all] [-l|--list] [--] args" | wrap "Usage ${0##*/} "
  echo "  help:      print this message"                                                | wrap "             "
  echo "  list:      list all known chroot environments"                                | wrap "             "
  echo "  clean:     remove all old chroot sessions for \"${chroot}\""                  | wrap "             "
  echo "  clean-all: remove all old chroot sessions for all environments"               | wrap "             "
  exit 0
}

clean()
{
  local s t rc
  rc=0
  for s in $(schroot -l --all-sessions); do
    if [ -n "$1" ]; then
      t="${s#session:}"
      [ "${t#${chroot}-}" == "${t}" ] && continue
    fi
    if ls -l /proc/*/{cwd,fd} 2>/dev/null |
       fgrep -qs "/var/lib/schroot/mount/${t}"; then
      echo "Session \"${t}\" still has active users, not cleaning up" | wrap
      rc=1
      continue
    fi
    sudo -A -- schroot -c "${s}" -e || rc=1
  done
  exit ${rc}
}

list()
{
  for e in $(schroot -l); do
    e="${e#chroot:}"
    [ -x "/usr/local/bin/${e}" ] || continue
    if schroot -l --all-sessions 2>/dev/null |
       sed 's/^session://' |
       grep -qs "^${e}-"; then
      echo "${e} is currently active"
    else
      echo "${e}"
    fi
  done
  return ${rc}
}

while [ "$#" -ne 0 ]; do
  case "$1" in
    --)             shift; break;;
    -h|--help)      shift; help;;
    -l|--list)      shift; list;;
    -c|--clean)     shift; clean "${chroot}"; exit ${?};;
    -C|--clean-all) shift; clean; exit ${?};;
    *)              break;;
  esac
done

# Start a new chroot session and keep track of the session id. We inject this
# id into all processes that run inside the chroot. Unless they go out of their
# way to clear their environment, we can then later identify our child and
# grand-child processes by scanning their environment.
session="$(schroot -c "${chroot}" -b)"
export CHROOT_SESSION_ID="${session}"

# Set GOMA_TMP_DIR for better handling of goma inside chroot.
export GOMA_TMP_DIR="/tmp/goma_tmp_$CHROOT_SESSION_ID"
mkdir -p "$GOMA_TMP_DIR"

if [ $# -eq 0 ]; then
  # Run an interactive shell session
  schroot -c "${session}" -r -p
else
  # Run a command inside of the chroot environment
  p="$1"; shift
  schroot -c "${session}" -r -p "$p" -- "$@"
fi
rc=$?

# Compute the inode of the root directory inside of the chroot environment.
i=$(schroot -c "${session}" -r -p ls -- -id /proc/self/root/. |
     awk '{ print $1 }') 2>/dev/null
other_pids=
while [ -n "$i" ]; do
  # Identify processes by the inode number of their root directory. Then
  # remove all processes that we know belong to other sessions. We use
  # "sort | uniq -u" to do what amounts to a "set substraction operation".
  pids=$({ ls -id1 /proc/*/root/. 2>/dev/null |
         sed -e 's,^[^0-9]*'$i'.*/\([1-9][0-9]*\)/.*$,\1,
                 t
                 d';
         echo "${other_pids}";
         echo "${other_pids}"; } | sort | uniq -u) >/dev/null 2>&1
  # Kill all processes that are still left running in the session. This is
  # typically an assortment of daemon processes that were started
  # automatically. They result in us being unable to tear down the session
  # cleanly.
  [ -z "${pids}" ] && break
  for j in $pids; do
    # Unfortunately, the way that schroot sets up sessions has the
    # side-effect of being unable to tell one session apart from another.
    # This can result in us attempting to kill processes in other sessions.
    # We make a best-effort to avoid doing so.
    k="$( ( xargs -0 -n1 </proc/$j/environ ) 2>/dev/null |
         sed 's/^CHROOT_SESSION_ID=/x/;t1;d;:1;q')"
    if [ -n "${k}" -a "${k#x}" != "${session}" ]; then
      other_pids="${other_pids}
${j}"
      continue
    fi
    kill -9 $pids
  done
done
# End the chroot session. This should clean up all temporary files. But if we
# earlier failed to terminate all (daemon) processes inside of the session,
# deleting the session could fail. When that happens, the user has to manually
# clean up the stale files by invoking us with "--clean" after having killed
# all running processes.
schroot -c "${session}" -e
# Since no goma processes are running, we can remove goma directory.
rm -rf "$GOMA_TMP_DIR"

clean "${chroot}"
exit $rc
EOF
    sudo -A -- chown root:root /usr/local/bin/${target%bit};
    sudo -A -- chmod 755 /usr/local/bin/${target%bit};

    # Add the standard Ubuntu update repositories if requested.
    [ "${alt_repos}" = "y" -a \
      -r "/var/lib/chroot/${target}/etc/apt/sources.list" ] &&
      sudo -A -- sed -i '/^deb .* [^ -]\+ main$/p
               s/^\(deb .* [^ -]\+\) main/\1-security main/
               p
               t1
               d
               :1;s/-security main/-updates main/
               t
               d' "/var/lib/chroot/${target}/etc/apt/sources.list"
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1

    # Add a few more repositories to the chroot
    [ -r "/var/lib/chroot/${target}/etc/apt/sources.list" ] &&
    sudo -A -- sed -i 's/ main$/ main restricted universe multiverse/' \
             "/var/lib/chroot/${target}/etc/apt/sources.list"
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1

    # Add the Ubuntu \"partner\" repository, if available
    if [ -r "/var/lib/chroot/${target}/etc/apt/sources.list" ] &&
       HEAD "http://archive.canonical.com/ubuntu/dists/${distname}/partner" \
       >&/dev/null; then
      sudo -A -- sh -c '
        echo "deb http://archive.canonical.com/ubuntu" \
             "'"${distname}"' partner" \
          >>"/var/lib/chroot/'"${target}"'/etc/apt/sources.list"'
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
    fi

    # Add source repositories, if the user requested we do so
    if [ "${add_srcs}" = "y" -a -r "/var/lib/chroot/${target}/etc/apt/sources.list" ];then
      sudo -A -- sed -i '/^deb[^-]/p
               s/^deb\([^-]\)/deb-src\1/' \
           "/var/lib/chroot/${target}/etc/apt/sources.list"
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
    fi

    # Set apt proxy if host has set http_proxy
    if [ -n "${http_proxy}" ]; then
      sudo -A -- sh -c '
        echo "Acquire::http::proxy \"'"${http_proxy}"'\";" \
            >>"/var/lib/chroot/'"${target}"'/etc/apt/apt.conf"'
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
    fi

    # Update packages
    sudo -A -- "/usr/local/bin/${target%bit}" apt-get update;
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
    sudo -A -- "/usr/local/bin/${target%bit}" apt-get -y dist-upgrade
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1

    # Install a couple of missing packages
    for i in debian-keyring ubuntu-keyring locales sudo; do
      [ -d "/var/lib/chroot/${target}/usr/share/doc/$i" ] ||
        sudo -A -- "/usr/local/bin/${target%bit}" apt-get -y install "$i" || :
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
    done

    # Configure locales
    sudo -A -- "/usr/local/bin/${target%bit}" /bin/sh -c '
      l='"${LANG:-en_US}"'; l="${l%%.*}"
      [ -r /etc/locale.gen ] &&
        sed -i "s/^# \($l\)/\1/" /etc/locale.gen
      locale-gen $LANG en_US en_US.UTF-8' || :
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1

    # Configure \"sudo\" package
    sudo -A -- "/usr/local/bin/${target%bit}" /bin/sh -c '
      egrep -qs '"'^$(id -nu) '"' /etc/sudoers ||
      echo '"'$(id -nu) ALL=(ALL) ALL'"' >>/etc/sudoers'
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1

    # Install a few more commonly used packages
    sudo -A -- "/usr
    /local/bin/${target%bit}" apt-get -y install                         \
            autoconf automake1.9 dpkg-dev g++-multilib gcc-multilib gdb less libtool     \
            lsof strace
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1

    # If running a 32bit environment on a 64bit machine, install a few binaries
    # as 64bit. This is only done automatically if the chroot distro is the same as
    # the host, otherwise there might be incompatibilities in build settings or
    # runtime dependencies. The user can force it with the '-c' flag.
    host_distro=$(grep -s DISTRIB_CODENAME /etc/lsb-release |  cut -d "=" -f 2)
    if [ "${copy_64}" = "y" -o \
        "${host_distro}" = "${distname}" -a "${arch}" = 32bit ] && \
        file /bin/bash 2>/dev/null | grep -q x86-64; then
      readlinepkg=$(sudo -A -- "/usr/local/bin/${target%bit}" sh -c \
        'apt-cache search "lib64readline.\$" | sort | tail -n 1 | cut -d " " -f 1')
      sudo -A -- "/usr/local/bin/${target%bit}" apt-get -y install                       \
        lib64expat1 lib64ncurses5 ${readlinepkg} lib64z1 lib64stdc++6
      dep=
      for i in binutils gdb; do
        [ -d /usr/share/doc/"$i" ] || dep="$dep $i"
      done
      [ -n "$dep" ] && sudo -A -- apt-get -y install $dep
      sudo -A -- mkdir -p "/var/lib/chroot/${target}/usr/local/lib/amd64"
      for i in libbfd libpython; do
        lib="$({ ldd /usr/bin/ld; ldd /usr/bin/gdb; } |
               grep -s "$i" | awk '{ print $3 }')"
        if [ -n "$lib" -a -r "$lib" ]; then
          sudo -A -- cp "$lib" "/var/lib/chroot/${target}/usr/local/lib/amd64"
        fi
      done
      for lib in libssl libcrypt; do
        for path in /usr/lib /usr/lib/x86_64-linux-gnu; do
          sudo -A -- cp $path/$lib* \
                  "/var/lib/chroot/${target}/usr/local/lib/amd64/" >&/dev/null || :
        done
      done
#      for i in gdb ld; do
#        sudo -A -- cp /usr/bin/$i "/var/lib/chroot/${target}/usr/local/lib/amd64/"
#        sudo -A -- sh -c "cat >'/var/lib/chroot/${target}/usr/local/bin/$i'" <<EOF
#!/bin/sh
#exec /lib64/ld-linux-x86-64.so.2 --library-path /usr/local/lib/amd64 \
#  /usr/local/lib/amd64/$i "\$@"
#EOF
#        sudo -A -- chmod 755 "/var/lib/chroot/${target}/usr/local/bin/$i"
#      done
      echo "OK"
    else
      echo "Not used"
    fi

    if [ -d /var/lib/chroot/${target}/usr/lib/i386-linux-gnu ];then
      ln -sf i386-linux-gnu /var/lib/chroot/${target}/usr/lib/i686-linux-gnu;fi

    # Clean up package files
    sudo -A -- schroot -c "${target%bit}" -p -- apt-get clean
    sudo -A -- apt-get clean

    echo "^^^^-----------------____ Basic installation finished ____---------------^^^^"
    echo ""

    rm -f "${TEMP_DIR}/build_active";
    sleep 15;
    exit 0;
  ) | sed -u "s/.*/# &/ w ${main_msg_tmp}" >> ${main_msg} &
  pid=$!
}
{
  tail -f --pid=$pid ${main_msg} |
    showdialog --title="Install" --image="$BASE_PATH/icons/icon-install-128x128.png" --progress \
               --width=600 \
               --text="Installing parts for \"${target%bit}\" on ${arch} architecture ..." \
               --pulsate --enable-log --log-height=300 --button=gtk-cancel:1 \
               --auto-close > /dev/null
  ret=$?
  cat $main_msg_tmp >> $build_log
  clean_schroot
  if [[ $ret != 0 ]];then
    showErrorDialog "\"${target%bit}\" installation cancelled.\nExiting"
    ps -p $pid
    [[ $? = 0 ]] && killtree $pid KILL
    rm -f "${TEMP_DIR}/build_active"
    exit 1
  elif [ -f "${TEMP_DIR}/build_active" ];then
    showErrorDialog "\"${target%bit}\" installation failed.\nExiting"
    rm -f "${TEMP_DIR}/build_active"
    exit 1
  fi
}

trap '' INT TERM QUIT HUP
trap '' EXIT

# Let the user know what we did
showdialog --title="Automatic build environment" \
           --image="$BASE_PATH/icons/icon-info-128x128.png" \
           --image-on-top --form \
           --button=gtk-ok:0 \
           --width=830 --show-uri --editable \
           --text-info \
           --text="<tt>
     <i><span size=\"large\">Successfully installed ${distname} ${arch}</span></i>
_________________________________________________________________________________________

     You can run programs inside of the chroot by invoking the
     <b>\"/usr/local/bin/${target%bit}\"</b> command.

      This command can be used with arguments, in order to just run a single
      program inside of the chroot environment (e.g. \"${target%bit} make chrome\")
      or without arguments, in order to run an interactive shell session inside
      of the chroot environment.

      If you need to run things as \"root\", you can use \"sudo\" (e.g. try
      \"sudo ${target%bit} apt-get update\").

      Your home directory is shared between the host and the chroot. But I
      configured \"${HOME}/chroot\" to be private to the chroot environment.
      You can use it for files that need to differ between environments. This
      would be a good place to store binaries that you have built from your
      source files.

      For Chrome, this probably means you want to make your \"out\" directory a
      symbolic link that points somewhere inside of \"${HOME}/chroot\".

      You still need to run \"gclient runhooks\" whenever you switch from building
      outside of the chroot to inside of the chroot. But you will find that you
      don\'t have to repeatedly erase and then completely rebuild all your object
      and binary files.</tt>" 2> /dev/null

exit_build 0
