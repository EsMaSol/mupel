#!/bin/bash
###############################################################################
#                                                                             #
#     Copyright (C) 2015 Team KODI                                            #
#     http://kodi.tv                                                          #
#                                                                             #
#  This program is free software: you can redistribute it and/or modify       #
#  it under the terms of the GNU General Public License as published by       #
#  the Free Software Foundation, either version 3 of the License, or          #
#  (at your option) any later version.                                        #
#                                                                             #
#  This program is distributed in the hope that it will be useful,            #
#  but WITHOUT ANY WARRANTY; without even the implied warranty of             #
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              #
#  GNU General Public License for more details.                               #
#                                                                             #
#  You should have received a copy of the GNU General Public License          #
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.      #
#                                                                             #
###############################################################################

BASE_PATH=${BASE_PATH:-$(cd $(dirname $0)/../.. ; pwd -P)}

. "$HOME/.mupel/mupel.conf"
. "$BASE_PATH/tools/tool_functions"
. "$BASE_PATH/tools/tool_install.include"

# To store needed cpu bit size, e.g. defined from script options or if not
# set selected from user.
# Only be used on 64bit systems
include_update=

function usage() {
  echo "usage: ${0##*/} [-m mirror] [-g group,...] [-s] [-c] [-t bits] [-u]"
  echo "-b dir       additional directories that should be bind mounted,"
  echo '             or "NONE".'
  echo "             Default: if local filesystems present, ask user for help"
  echo "-g group,... groups that can use the chroot unauthenticated"
  echo "             Default: '${admin}' and current user's group ('$(id -gn)')"
  echo "-m mirror    an alternate repository mirror for package downloads"
  echo "-s           configure default deb-srcs"
  echo "-c           always copy 64bit helper binaries to 32bit chroot"
  echo "-u           to add updates and security to the chroot's sources.list"
  echo "-n           no install of build dependencies now"
  echo "-f           if set install is related to a flow and several messages becomes not used"
  echo "-h           this help message"
}

function process_opts()
{
  local OPTNAME OPTIND OPTERR OPTARG
  while getopts ":b:g:m:schunfr" OPTNAME; do
  {
    case "$OPTNAME" in
      b)
        if [ "${OPTARG}" = "NONE" ] && [ -z "${bind_mounts}" ];then
          bind_mounts="${OPTARG}"
        else
        {
          if [ "${bind_mounts}" = "NONE" ] || [ "${OPTARG}" = "${OPTARG#/}" ] || [ ! -d "${OPTARG}" ];then
          {
            echo "Invalid -b option(s)"
            usage
            exit 1
          } fi
          bind_mounts="${bind_mounts}
${OPTARG} ${OPTARG} none rw,bind 0 0"
        } fi
        ;;
      g)
        [ -n "${OPTARG}" ] &&
          chroot_groups="${chroot_groups}${chroot_groups:+,}${OPTARG}"
        ;;
      m)
        if [ -n "${mirror}" ];then
        {
          echo "You can only specify exactly one mirror location"
          usage
          exit 1
        } fi
        mirror="$OPTARG"
        ;;
      s)
        add_srcs="y"
        ;;
      c)
        copy_64="y"
        ;;
      u)
        include_update="TRUE"
        ;;
      n)
        no_install_build_deps="y"
        ;;
      f)
        full_install_flow="y"
        ;;
      r) # rework
        rework="y"
        ;;
      h)
        usage
        exit 0
        ;;
      \:)
        echo "'-$OPTARG' needs an argument."
        usage
        exit 1
        ;;
      *)
        echo "invalid command-line option: $OPTARG"
        usage
        exit 1
        ;;
    esac
  } done

  if [ $# -ge ${OPTIND} ];then
  {
    eval echo "Unexpected command line argument: \${${OPTIND}}"
    usage
    exit 1
  } fi
}

function exit_build()
{
  local ret=$1
  rm -rf $TEMP_DIR
  exit $ret
}

# Check for non-standard file system mount points and ask the user whether
# they should be imported into the chroot environment
# We limit to the first 26 mount points that much some basic heuristics,
# because a) that allows us to enumerate choices with a single character,
# and b) if we find more than 26 mount points, then these are probably
# false-positives and something is very unusual about the system's
# configuration. No need to spam the user with even more information that
# is likely completely irrelevant.
function checkMountPoints()
{
  local mounts="$(awk '$2 != "/" && $2 !~ "^/boot" && $2 !~ "^/home" &&
                 $2 !~ "^/media" && $2 !~ "^/run" &&
                 ($3 ~ "ext[2-4]" || $3 == "reiserfs" || $3 == "btrfs" ||
                 $3 == "xfs" || $3 == "jfs" || $3 == "u?msdos" ||
                 $3 == "v?fat" || $3 == "hfs" || $3 == "ntfs" ||
                 $3 ~ "nfs[4-9]?" || $3 == "smbfs" || $3 == "cifs") {
                   print $2
                 }' /proc/mounts |
            head -n26)"
  if [ -n "${mounts}" ]; then
  {
    targets=
    for i in $mounts; do
      targets=`printf "$targets OFF %s" "$i"`;done

      mounts=$(showdialog --list --checklist \
                        --text="\
You appear to have non-standard mount points that you
might want to import into the chroot environment.

Select mount points that you want to be included or
ignore for \"${target%bit}\"" \
                        --column "Use" \
                        --column "Point" $targets \
                        --print-column=2 \
                        --width=400 --height=390 2> /dev/null)
  } fi

  IFS=$'|\n'; for m in ${mounts}; do
  {
      bind_mounts="${bind_mounts}$m $m none rw,bind 0 0
"
  } done
  unset IFS
}

function system_update()
{
  local distname=$1
  local arch=$2
  local target="${arch%bit}"

  extra_list=
#  if [ "$target" == "32" ] && [ "$USE_LINUX_RPBI" == "TRUE" ];then
#  {
#    # arm cross toolchain packages needed to build chrome on armhf
#    extra_list="libc6-dev-armhf-cross linux-libc-dev-armhf-cross g++-arm-linux-gnueabihf";
#
#    # Work around for dependency issue Ubuntu/Trusty: http://crbug.com/435056
#    if [ "$distname" = "trusty" ]; then
#    {
#      extra_list+=" g++-4.8-multilib-arm-linux-gnueabihf gcc-4.8-multilib-arm-linux-gnueabihf";
#    } fi
#  } fi
  if [ "$target" == "64" ];then
  {
    if [ "$USE_ANDROID_X86" == "TRUE" ] || [ "$USE_ANDROID_ARM" == "TRUE" ];then
    {
      # arm cross toolchain packages needed to build chrome on armhf
      extra_list+=" build-essential default-jdk git curl autoconf lib32stdc++6 lib32z1 lib32z1-dev";
    } fi
  } fi

  while :; do
  {
    {
      (
        touch "${TEMP_DIR}/build_active"
        printf "\n# Installing main build dependencies\n";

        # Override with own distribution package list if present
        if [ -f $BASE_PATH/tools/linux/kodi-install-parts.${distname} ];then
          install_list=$BASE_PATH/tools/linux/general-install-parts.${distname}
        else
          install_list=$BASE_PATH/tools/linux/general-install-parts;fi
        sudo -A -- ${distname}${target} \
          apt-get -y -q install `cat $install_list` $extra_list;
        [ ${PIPESTATUS[0]} != 0 ] && exit 1;

        rm -f "${TEMP_DIR}/build_active";
        sleep 5;
        exit 0;
      ) | sed -u "s/.*/# &/" >> ${main_msg_tmp} &
      pid=$!;
    }
    {
      tail -f --pid=$pid ${main_msg_tmp} |
        showdialog --title="Install" --image="$BASE_PATH/icons/icon-install-128x128.png" --progress --width=600 \
                   --text="Install general related build depends - ${distname}${target} ..." \
                   --pulsate --enable-log --log-height=300 --button=gtk-cancel:1 \
                   --auto-close > /dev/null;
      ret=$?
      cat $main_msg_tmp >> $build_log
      echo "" > $main_msg_tmp
      if [[ $ret != 0 ]];then
      {
        ps -p $pid;
        [[ $? = 0 ]] && killtree $pid KILL;
      }
      elif [ -f "${TEMP_DIR}/build_active" ];then
      {
        ret=1;
      } fi
      unset pid;
      rm -f "${TEMP_DIR}/build_active";
    }
    if [[ $ret != 0 ]];then
    {
      showWarningDialog_YesNo "Installation general related build depends failed - ${distname}${target}! \n\nTry again?";
      [ $? != 0 ] && exit_build $ret;
    }
    else
      break;fi
  } done

  if [ $include_kodi_dep = "TRUE" ];then
  {
    while :; do
    {
      {
        (
          touch "${TEMP_DIR}/build_active"
          printf "\nInstall kodi's related build depends\n";
          [ $include_kodi_devel = "TRUE" ] && used_distname=devel || used_distname=$distname;
          if [ -r "/var/lib/chroot/${distname}${target}bit/etc/apt/sources.list" ] &&
             HEAD "http://ppa.launchpad.net/team-xbmc/ppa/ubuntu/dists/${used_distname}" \
             >&/dev/null; then
          {
            present_repo=$(grep -F xbmc "/var/lib/chroot/${distname}${target}bit/etc/apt/sources.list");
            if [[ ! -z $present_repo ]] &&  [[ -z `echo $present_repo | grep -F "${used_distname}"` ]];then
              sudo sed --in-place '/team-xbmc/d' /var/lib/chroot/${distname}${target}bit/etc/apt/sources.list;fi

            if [[ -z `echo $present_repo | grep -F "${used_distname}"` ]];then
            {
              sudo -A -- ${distname}${target} apt-get -y -q install software-properties-common >> $build_log
              sudo -A -- ${distname}${target} add-apt-repository --yes ppa:team-xbmc/ppa >> $build_log

              sudo -A -- sh -c '
                echo "deb http://ppa.launchpad.net/team-xbmc/ppa/ubuntu" \
                     "'"${used_distname}"' main" \
                  >>"/var/lib/chroot/'"${distname}${target}bit"'/etc/apt/sources.list"'
              [ $? != 0 ] && printf "Failed 7\n\n" && exit 1
              sudo -A -- sh -c '
                echo "deb-src http://ppa.launchpad.net/team-xbmc/ppa/ubuntu" \
                     "'"${used_distname}"' main" \
                  >>"/var/lib/chroot/'"${distname}${target}bit"'/etc/apt/sources.list"'
              [ $? != 0 ] && printf "Failed 7\n\n" && exit 1
              sudo -A -- ${distname}${target} apt-get update
            } fi
          }
          else
          {
            showWarningDialog_YesNo "Set of kodi's repository failed - ${distname}${target}! \n\nTry again?";
            [ $? != 0 ] && exit_build 1;
            continue;
          } fi

          sudo -A -- ${distname}${target} \
            apt-get -y -q build-dep kodi

          # Override with own distribution package list if present
          if [ -f $BASE_PATH/tools/linux/kodi-install-parts.${distname} ];then
            install_list=$BASE_PATH/tools/linux/kodi-install-parts.${distname}
          else
            install_list=$BASE_PATH/tools/linux/kodi-install-parts;fi
          sudo -A -- ${distname}${target} \
            apt-get -y -q install `cat $install_list`;
          [ ${PIPESTATUS[0]} != 0 ] && exit 1;

          rm -f "${TEMP_DIR}/build_active";
          sleep 5;
          exit 0;
        ) | sed -u "s/.*/# &/" >> ${main_msg_tmp} &
        pid=$!;
      }
      {
        tail -f --pid=$pid ${main_msg_tmp} |
          showdialog --title="Install" --image="$BASE_PATH/icons/icon-install-128x128.png" --progress --width=600 \
                     --text="Install kodi's related build depends - ${distname}${target} ..." \
                     --pulsate --enable-log --log-height=300 --button=gtk-cancel:1 \
                     --auto-close > /dev/null;
        ret=$?;
        cat $main_msg_tmp >> $build_log
        echo "" > $main_msg_tmp
        if [[ $ret != 0 ]];then
        {
          ps -p $pid;
          [[ $? = 0 ]] && killtree $pid KILL
        }
        elif [ -f "${TEMP_DIR}/build_active" ];then
        {
          ret=1;
        } fi
        unset pid;
        rm -f "${TEMP_DIR}/build_active";
      }
      if [[ $ret != 0 ]];then
      {
        showWarningDialog_YesNo "Installation kodi's related build depends failed - ${distname}${target}! \n\nTry again?";
        [ $? != 0 ] && exit_build $ret;
      }
      else
        break;fi
    } done
  } fi

  if [ $include_cef_dep = "TRUE" ];then
  {
    while :; do
    {
      {
        (
          touch "${TEMP_DIR}/build_active"
          printf "\nInstall chromium CEF related build depends\n";
          # Override with own distribution package list if present
          if [ -f $BASE_PATH/tools/linux/cef-install-parts.${distname} ];then
            install_list=$BASE_PATH/tools/linux/cef-install-parts.${distname}
          else
            install_list=$BASE_PATH/tools/linux/cef-install-parts;fi
          sudo -A -- ${distname}${target} \
            apt-get -y -q install `cat $install_list`;
          [ ${PIPESTATUS[0]} != 0 ] && exit 1;

          rm -f "${TEMP_DIR}/build_active";
          sleep 5;
          exit 0;
        ) | sed -u "s/.*/# &/" >> ${main_msg_tmp} &
        pid=$!;
      }
      {
        tail -f --pid=$pid ${main_msg_tmp} |
          showdialog --title="Install" --image="$BASE_PATH/icons/icon-install-128x128.png" --progress --width=600 \
                     --text="Install chromium CEF related build depends - ${distname}${target} ..." \
                     --pulsate --enable-log --log-height=300 --button=gtk-cancel:1 \
                     --auto-close > /dev/null;
        ret=$?;
        cat $main_msg_tmp >> $build_log
        echo "" > $main_msg_tmp
        if [[ $ret != 0 ]];then
        {
          ps -p $pid;
          [[ $? = 0 ]] && killtree $pid KILL;
        }
        elif [ -f "${TEMP_DIR}/build_active" ];then
        {
          ret=1;
        } fi
        unset pid;
        rm -f "${TEMP_DIR}/build_active";
      }
      if [[ $ret != 0 ]];then
      {
        showWarningDialog_YesNo "Installation chromium CEF related build depends failed - ${distname}${target}! \n\nTry again?";
        [ $? != 0 ] && exit_build $ret;
      }
      else
        break;fi
    } done
  } fi
}

function system_overwrite()
{
  local distname=$1
  local arch=$2
  local target="${distname}${arch}"

  sudo -A -- rm -rfv /var/lib/chroot/${target} |
    showdialog --title="Install" --image="$BASE_PATH/icons/icon-install-128x128.png" --progress --width=600 \
               --text="Removing old distribution ${distname} ..." \
               --pulsate --log-height=300 --button=gtk-cancel:1 \
               --auto-close > /dev/null;

  system_install $distname $arch
}

function system_install()
{
  local distname=$1;
  local arch=$2;
  local target="${distname}${arch}";

  local archflag;
  [ "${arch}" == "32bit" ] && archflag="--arch i386" || archflag="--arch amd64"

  sudo -A -- mkdir -p /var/lib/chroot/${target}
  (
    touch "${TEMP_DIR}/build_active"
    printf "\n# ------ Install of \"${distname}\" for ${arch} started ------\n"

    # Remove stale entry from /etc/schroot/schroot.conf. Entries start
    # with the target name in square brackets, followed by an arbitrary
    # number of lines. The entry stops when either the end of file has
    # been reached, or when the beginning of a new target is encountered.
    # This means, we cannot easily match for a range of lines in
    # "sed". Instead, we actually have to iterate over each line and check
    # whether it is the beginning of a new entry.
    sudo -A -- sed -ni '/^[[]'"${target%bit}"']$/,${:1;n;/^[[]/b2;b1;:2;p;n;b2};p' /etc/schroot/schroot.conf

    # Download base system. This takes some time
    if [ -z "${mirror}" ]; then
    {
      grep -qs ubuntu.com /usr/share/debootstrap/scripts/"${distname}" &&
        mirror="http://archive.ubuntu.com/ubuntu" ||
        mirror="http://ftp.us.debian.org/debian"
      err=$?; [ $err != 0 ] && showErrorDialog "Download base system failed, Error code: $err" && exit_build 1
    }
    fi

    # Load basic distribution parts
    sudo -A -- ${http_proxy:+http_proxy="${http_proxy}"} debootstrap ${archflag} "${distname}" "/var/lib/chroot/${target}"  "$mirror" > "/dev/stdout" 2>&1
    err=$?; [ $err != 0 ] && showErrorDialog "Load basic distribution parts failed, Error code: $err" && exit_build 1

    # Add new entry to /etc/schroot/schroot.conf
    grep -qs ubuntu.com /usr/share/debootstrap/scripts/"${distname}" &&
      brand="Ubuntu" || brand="Debian"

    if [ -z "${chroot_groups}" ];then
      chroot_groups="${admin},$(id -gn)";fi

    if [ -d '/etc/schroot/default' ]; then
      new_version=1
      fstab="/etc/schroot/${target}/fstab"
    else
      new_version=0
      fstab="/etc/schroot/mount-${target}"
    fi

    if [ "$new_version" = "1" ]; then
      sudo -A -- cp -ar /etc/schroot/default /etc/schroot/${target};
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
      sudo -A -- sh -c 'cat >>/etc/schroot/schroot.conf' <<EOF
[${target%bit}]
description=${brand} ${distname} ${arch}
type=directory
directory=/var/lib/chroot/${target}
users=root
groups=${chroot_groups}
root-groups=${chroot_groups}
personality=linux$([ "${arch}" != 64bit ] && echo 32)
profile=${target}

EOF
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1

      [ -n "${bind_mounts}" -a "${bind_mounts}" != "NONE" ] &&
        printf "${bind_mounts}" |
          sudo -A -- sh -c 'cat >>'"${fstab}"
    else
      # Older versions of schroot wanted a "priority=" line, whereas recent
      # versions deprecate "priority=" and warn if they see it. We don't have
      # a good feature test, but scanning for the string "priority=" in the
      # existing "schroot.conf" file is a good indication of what to do.
      priority=$(grep -qs 'priority=' /etc/schroot/schroot.conf && echo 'priority=3' || :)
      sudo -A -- "bash -c 'cat >>/etc/schroot/schroot.conf'" << 'EOF'
[${target%bit}]
description=${brand} ${distname} ${arch}
type=directory
directory=/var/lib/chroot/${target}
users=root
groups=${chroot_groups}
root-groups=${chroot_groups}
personality=linux$([ "${arch}" != 64bit ] && echo 32)
script-config=script-${target}
${priority}

EOF

      # Set up a list of mount points that is specific to this chroot environment.
      sed '/^FSTAB=/s,"[^"]*","/etc/schroot/mount-'"${target}"'",' \
        /etc/schroot/script-defaults | sudo -A -- sh -c 'cat > /etc/schroot/script-'"${target}"
      sed '\,^/home[/[:space:]],s/\([,[:space:]]\)bind[[:space:]]/\1rbind /' \
        /etc/schroot/mount-defaults | sudo -A -- sh -c 'cat > /etc/schroot/mount-'"${target}"
    fi

    # Add the extra mount points that the user told us about
    [ -n "${bind_mounts}" -a "${bind_mounts}" != "NONE" ] &&
      printf "${bind_mounts}" | sudo -A -- sh -c 'cat >>'"${fstab}"

    # If this system has a \"/media\" mountpoint, import it into the chroot
    # environment. Most modern distributions use this mount point to
    # automatically mount devices such as CDROMs, USB sticks, etc...
    if [ -d /media ] && ! grep -qs '^/media' "${fstab}";then
      echo '/media /media none rw,rbind 0 0' | sudo -A -- sh -c 'cat >>'"${fstab}";fi

    # Share /dev/shm, /run and /run/shm.
    grep -qs '^/dev/shm' "${fstab}" ||
      echo '/dev/shm /dev/shm none rw,bind 0 0' |
        sudo -A -- sh -c 'cat >>'"${fstab}"
    if [ ! -d "/var/lib/chroot/${target}/run" ] && ! grep -qs '^/run' "${fstab}";then
      echo '/run /run none rw,bind 0 0' | sudo -A -- sh -c 'cat >>'"${fstab}";fi
    if ! grep -qs '^/run/shm' "${fstab}";then
    {
      { [ -d /run ] && echo '/run/shm /run/shm none rw,bind 0 0' ||
                       echo '/dev/shm /run/shm none rw,bind 0 0'; } |
        sudo -A -- sh -c 'cat >>'"${fstab}"
    } fi

    # if /run/user/1000 is already present and enabled disable it to prevent umount
    # problems on install
    if grep -qs '^/run/user/1000' "${fstab}";then
      sudo -A perl -pi -e 's/^\/run\/user\/1000/#\/run\/user\/1000/g' "${fstab}"
    else
      echo '/run/user/1000  /run/user/1000  none    rw,bind         0       0' | sudo -A -- sh -c 'cat >>'"${fstab}";fi

    # Install a helper script to launch commands in the chroot
    sudo -A -- sh -c 'cat > /usr/local/bin/'"${target%bit}" << EOF
#!/bin/bash

export SUDO_ASKPASS="$BASE_PATH/tools/sudo-askpass"
EOF
    sudo -A -- sh -c 'cat >> /usr/local/bin/'"${target%bit}" << 'EOF'
chroot="${0##*/}"

wrap()
{
  # Word-wrap the text passed-in on stdin. Optionally, on continuation lines
  # insert the same number of spaces as the number of characters in the
  # parameter(s) passed to this function.
  # If the "fold" program cannot be found, or if the actual width of the
  # terminal cannot be determined, this function doesn't attempt to do any
  # wrapping.
  local f="$(type -P fold)"
  [ -z "${f}" ] && { cat; return; }
  local c="$(stty -a </dev/tty 2>/dev/null |
             sed 's/.*columns[[:space:]]*\([0-9]*\).*/\1/;t;d')"
  [ -z "${c}" ] && { cat; return; }
  local i="$(echo "$*"|sed 's/./ /g')"
  local j="$(printf %s "${i}"|wc -c)"
  if [ "${c}" -gt "${j}" ]; then
    dd bs=1 count="${j}" 2>/dev/null
    "${f}" -sw "$((${c}-${j}))" | sed '2,$s/^/'"${i}"'/'
  else
    "${f}" -sw "${c}"
  fi
}

help() {
  echo "Usage ${0##*/} [-h|--help] [-c|--clean] [-C|--clean-all] [-l|--list] [--] args" | wrap "Usage ${0##*/} "
  echo "  help:      print this message"                                                | wrap "             "
  echo "  list:      list all known chroot environments"                                | wrap "             "
  echo "  clean:     remove all old chroot sessions for \"${chroot}\""                  | wrap "             "
  echo "  clean-all: remove all old chroot sessions for all environments"               | wrap "             "
  exit 0
}

clean()
{
  local s t rc
  rc=0
  for s in $(schroot -l --all-sessions); do
    if [ -n "$1" ]; then
      t="${s#session:}"
      [ "${t#${chroot}-}" == "${t}" ] && continue
    fi
    if ls -l /proc/*/{cwd,fd} 2>/dev/null |
       fgrep -qs "/var/lib/schroot/mount/${t}"; then
      echo "Session \"${t}\" still has active users, not cleaning up" | wrap
      rc=1
      continue
    fi
    sudo -A -- schroot -c "${s}" -e || rc=1
  done
  exit ${rc}
}

list()
{
  for e in $(schroot -l); do
    e="${e#chroot:}"
    [ -x "/usr/local/bin/${e}" ] || continue
    if schroot -l --all-sessions 2>/dev/null |
       sed 's/^session://' |
       grep -qs "^${e}-"; then
      echo "${e} is currently active"
    else
      echo "${e}"
    fi
  done
  return ${rc}
}

while [ "$#" -ne 0 ]; do
  case "$1" in
    --)             shift; break;;
    -h|--help)      shift; help;;
    -l|--list)      shift; list;;
    -c|--clean)     shift; clean "${chroot}"; exit ${?};;
    -C|--clean-all) shift; clean; exit ${?};;
    *)              break;;
  esac
done

# Start a new chroot session and keep track of the session id. We inject this
# id into all processes that run inside the chroot. Unless they go out of their
# way to clear their environment, we can then later identify our child and
# grand-child processes by scanning their environment.
session="$(schroot -c "${chroot}" -b)"
export CHROOT_SESSION_ID="${session}"

# Set GOMA_TMP_DIR for better handling of goma inside chroot.
export GOMA_TMP_DIR="/tmp/goma_tmp_$CHROOT_SESSION_ID"
mkdir -p "$GOMA_TMP_DIR"

if [ $# -eq 0 ]; then
  # Run an interactive shell session
  schroot -c "${session}" -r -p
else
  # Run a command inside of the chroot environment
  p="$1"; shift
  schroot -c "${session}" -r -p "$p" -- "$@"
fi
rc=$?

# Compute the inode of the root directory inside of the chroot environment.
i=$(schroot -c "${session}" -r -p ls -- -id /proc/self/root/. |
     awk '{ print $1 }') 2>/dev/null
other_pids=
while [ -n "$i" ]; do
  # Identify processes by the inode number of their root directory. Then
  # remove all processes that we know belong to other sessions. We use
  # "sort | uniq -u" to do what amounts to a "set substraction operation".
  pids=$({ ls -id1 /proc/*/root/. 2>/dev/null |
         sed -e 's,^[^0-9]*'$i'.*/\([1-9][0-9]*\)/.*$,\1,
                 t
                 d';
         echo "${other_pids}";
         echo "${other_pids}"; } | sort | uniq -u) >/dev/null 2>&1
  # Kill all processes that are still left running in the session. This is
  # typically an assortment of daemon processes that were started
  # automatically. They result in us being unable to tear down the session
  # cleanly.
  [ -z "${pids}" ] && break
  for j in $pids; do
    # Unfortunately, the way that schroot sets up sessions has the
    # side-effect of being unable to tell one session apart from another.
    # This can result in us attempting to kill processes in other sessions.
    # We make a best-effort to avoid doing so.
    k="$( ( xargs -0 -n1 </proc/$j/environ ) 2>/dev/null |
         sed 's/^CHROOT_SESSION_ID=/x/;t1;d;:1;q')"
    if [ -n "${k}" -a "${k#x}" != "${session}" ]; then
      other_pids="${other_pids}
${j}"
      continue
    fi
    kill -9 $pids
  done
done
# End the chroot session. This should clean up all temporary files. But if we
# earlier failed to terminate all (daemon) processes inside of the session,
# deleting the session could fail. When that happens, the user has to manually
# clean up the stale files by invoking us with "--clean" after having killed
# all running processes.
schroot -c "${session}" -e
# Since no goma processes are running, we can remove goma directory.
rm -rf "$GOMA_TMP_DIR"

clean "${chroot}"
exit $rc
EOF
    sudo -A -- chown root:root /usr/local/bin/${target%bit};
    sudo -A -- chmod 755 /usr/local/bin/${target%bit};

    # Add the standard Ubuntu update repositories if requested.
    if [ "${include_update}" = "TRUE" -a \
        -r "/var/lib/chroot/${target}/etc/apt/sources.list" ];then
    {
      sudo -A -- sed -i '/^deb .* [^ -]\+ main$/p
               s/^\(deb .* [^ -]\+\) main/\1-security main/
               p
               t1
               d
               :1;s/-security main/-updates main/
               t
               d' "/var/lib/chroot/${target}/etc/apt/sources.list"
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
    } fi

    # Add a few more repositories to the chroot
    if [ -r "/var/lib/chroot/${target}/etc/apt/sources.list" ];then
    {
      sudo -A -- sed -i 's/ main$/ main restricted universe multiverse/' "/var/lib/chroot/${target}/etc/apt/sources.list"
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
    } fi

    # Add the Ubuntu \"partner\" repository, if available
    if [ -r "/var/lib/chroot/${target}/etc/apt/sources.list" ] &&
       HEAD "http://archive.canonical.com/ubuntu/dists/${distname}/partner" \
       >&/dev/null; then
      sudo -A -- sh -c '
        echo "deb http://archive.canonical.com/ubuntu" \
             "'"${distname}"' partner" \
          >>"/var/lib/chroot/'"${target}"'/etc/apt/sources.list"'
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
    fi

    # Add source repositories, if the user requested we do so
    if [ "${add_srcs}" = "y" -a -r "/var/lib/chroot/${target}/etc/apt/sources.list" ];then
      sudo -A -- sed -i '/^deb[^-]/p
               s/^deb\([^-]\)/deb-src\1/' \
           "/var/lib/chroot/${target}/etc/apt/sources.list"
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
    fi

    # Set apt proxy if host has set http_proxy
    if [ -n "${http_proxy}" ]; then
      sudo -A -- sh -c '
        echo "Acquire::http::proxy \"'"${http_proxy}"'\";" \
            >>"/var/lib/chroot/'"${target}"'/etc/apt/apt.conf"'
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
    fi

    # Update packages
    sudo -A -- "/usr/local/bin/${target%bit}" apt-get update;
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
    sudo -A -- "/usr/local/bin/${target%bit}" apt-get -y dist-upgrade
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1

    # Install a couple of missing packages
    for i in debian-keyring ubuntu-keyring locales sudo; do
      [ -d "/var/lib/chroot/${target}/usr/share/doc/$i" ] ||
        sudo -A -- "/usr/local/bin/${target%bit}" apt-get -y install "$i" || :
      err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
    done

    # Configure locales
    sudo -A -- "/usr/local/bin/${target%bit}" /bin/sh -c '
      l='"${LANG:-en_US}"'; l="${l%%.*}"
      [ -r /etc/locale.gen ] &&
        sed -i "s/^# \($l\)/\1/" /etc/locale.gen
      locale-gen $LANG en_US en_US.UTF-8' || :
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1

    # Configure \"sudo\" package
    sudo -A -- "/usr/local/bin/${target%bit}" /bin/sh -c '
      egrep -qs '"'^$(id -nu) '"' /etc/sudoers ||
      echo '"'$(id -nu) ALL=(ALL) ALL'"' >>/etc/sudoers'
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1

    # Install a few more commonly used packages
    sudo -A -- "/usr/local/bin/${target%bit}" apt-get -y install                         \
            autoconf automake1.9 dpkg-dev g++-multilib gcc-multilib gdb less libtool     \
            lsof strace
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1

    # If running a 32bit environment on a 64bit machine, install a few binaries
    # as 64bit. This is only done automatically if the chroot distro is the same as
    # the host, otherwise there might be incompatibilities in build settings or
    # runtime dependencies. The user can force it with the '-c' flag.
    host_distro=$(grep -s DISTRIB_CODENAME /etc/lsb-release |  cut -d "=" -f 2)
    if [ "${copy_64}" = "y" -o \
        "${host_distro}" = "${distname}" -a "${arch}" = 32bit ] && \
        file /bin/bash 2>/dev/null | grep -q x86-64; then
      readlinepkg=$(sudo -A -- "/usr/local/bin/${target%bit}" sh -c \
        'apt-cache search "lib64readline.\$" | sort | tail -n 1 | cut -d " " -f 1')
      sudo -A -- "/usr/local/bin/${target%bit}" apt-get -y install                       \
        lib64expat1 lib64ncurses5 ${readlinepkg} lib64z1 lib64stdc++6
      dep=
      for i in binutils gdb; do
        [ -d /usr/share/doc/"$i" ] || dep="$dep $i"
      done
      [ -n "$dep" ] && sudo -A -- apt-get -y install $dep
      sudo -A -- mkdir -p "/var/lib/chroot/${target}/usr/local/lib/amd64"
      for i in libbfd libpython; do
        lib="$({ ldd /usr/bin/ld; ldd /usr/bin/gdb; } |
               grep -s "$i" | awk '{ print $3 }')"
        if [ -n "$lib" -a -r "$lib" ]; then
          sudo -A -- cp "$lib" "/var/lib/chroot/${target}/usr/local/lib/amd64"
        fi
      done
      for lib in libssl libcrypt; do
        for path in /usr/lib /usr/lib/x86_64-linux-gnu; do
          sudo -A -- cp $path/$lib* \
                  "/var/lib/chroot/${target}/usr/local/lib/amd64/" >&/dev/null || :
        done
      done
#      for i in gdb ld; do
#        sudo -A -- cp /usr/bin/$i "/var/lib/chroot/${target}/usr/local/lib/amd64/"
#        sudo -A -- sh -c "cat >'/var/lib/chroot/${target}/usr/local/bin/$i'" <<EOF
#!/bin/sh
#exec /lib64/ld-linux-x86-64.so.2 --library-path /usr/local/lib/amd64 \
#  /usr/local/lib/amd64/$i "\$@"
#EOF
#        sudo -A -- chmod 755 "/var/lib/chroot/${target}/usr/local/bin/$i"
#      done
      echo "OK"
    else
      echo "Not used"
    fi

    if [ -d /var/lib/chroot/${target}/usr/lib/i386-linux-gnu ];then
      ln -sf i386-linux-gnu /var/lib/chroot/${target}/usr/lib/i686-linux-gnu;fi

    # enable /run/user/1000 again
    if grep -qs '^#/run/user/1000' "${fstab}";then
      sudo -A perl -pi -e 's/^#\/run\/user\/1000/\/run\/user\/1000/g' "${fstab}";fi

    # Clean up package files
    sudo -A -- schroot -c "${target%bit}" -p -- apt-get clean
    sudo -A -- apt-get clean

    echo "^^^^-----------------____ Basic installation finished ____---------------^^^^"
    echo ""

    rm -f "${TEMP_DIR}/build_active";
    sleep 15;
    exit 0;
  ) | sed -u "s/.*/# &/" >> ${main_msg_tmp} &
  pid=$!
  tail -f --pid=$pid ${main_msg_tmp} |
    showdialog --title="Install" --image="$BASE_PATH/icons/icon-install-128x128.png" --progress \
               --width=600 \
               --text="Installing parts for \"${target%bit}\" on ${arch} architecture ..." \
               --pulsate --enable-log --log-height=300 --button=gtk-cancel:1 \
               --auto-close > /dev/null
  ret=$?
  cat $main_msg_tmp >> $build_log
  echo "" > $main_msg_tmp
  clean_schroot
  if [[ $ret != 0 ]];then
    showErrorDialog "\"${target%bit}\" installation cancelled.\nExiting"
    ps -p $pid
    [[ $? = 0 ]] && killtree $pid KILL
    rm -f "${TEMP_DIR}/build_active"
    touch ${TEMP_DIR}/linux-install.failed
    exit 1
  elif [ -f "${TEMP_DIR}/build_active" ];then
    showErrorDialog "\"${target%bit}\" installation failed.\nExiting"
    rm -f "${TEMP_DIR}/build_active"
    touch ${TEMP_DIR}/linux-install.failed
    exit 1
  fi
  unset pid;

  system_update $distname $arch
}

function system_uninstall()
{
  local target=$1
  sudo -A -- rm -rvf /var/lib/chroot/${target}      \
                    /usr/local/bin/${target%bit}   \
                    /etc/schroot/mount-${target}   \
                    /etc/schroot/script-${target}  \
                    /etc/schroot/${target}
  sudo -A -- sed -ni '/^[[]'"${target%bit}"']$/,${
                       :1;n;/^[[]/b2;b1;:2;p;n;b2};p' \
                     "/etc/schroot/schroot.conf"
}

function check_system_active()
{
  local distname=$1
  local arch=$2
  local target="${distname}${arch}"

  # Don't accidentally overwrite an existing installation
  if [ -d /var/lib/chroot/"${target}" ];then
  {
    while :; do
    {
      if schroot -l --all-sessions 2>&1 |
         sed 's/^session://' |
         grep -qs "^${target%bit}-"; then
      {
        showQuestionDialog "\
<b><i><span size=\"large\">This chroot \"${target%bit}\" already exists on your machine.</span></i></b>

And it appears to be in active use. Terminate all programs that
are currently using the chroot environment and then re-run this
script.

If you still get an error message, you might have stale mounts
that you forgot to delete. You can always clean up mounts by
executing \"<i>${target%bit} -c</i>\".

If removed continue with yes, no cancel build.";
        [ $? != 0 ] && exit_build 1;
        continue;
      } fi
      break;
    } done
  } fi
}

# Checks whether a particular package is available in the repos.
# USAGE: $ package_exists <package name>
package_exists()
{
  apt-cache pkgnames | grep -x "$1" > /dev/null 2>&1
}

###-------------------------------------------------------------------------###
#                                                                             #
#                            Start of process points                          #
#                                                                             #

DIST=`grep DISTRIB_ID /etc/*-release | awk -F '=' '{print $2}'`
[ $DIST != "Ubuntu" ] && [ $DIST != "Debian" ] && {
  echo "${RED}${BRIGHT}Build not possible, need performed on ubuntu or debian based system (needed for install of dependencies parts)${NORMAL}" >&2;
  exit 1 ;
}

# Check that xserver is running and user is root.
[[ $DISPLAY ]] || {
  echo $"${RED}${BRIGHT}There is no xserver running. Exiting...${NORMAL}";
  exit 1;
}

[[ `uname -m` != "x86_64" ]] && {
  echo $"${RED}${BRIGHT}Wrong system, a 64 bit linux OS is needed!${NORMAL}";
  exit_build 1
}

# Check that we are running as a regular user
[ "$(id -nu)" = root ] && {
  printf "${RED}${BRIGHT}Run this script as a regular user and provide your \"sudo\" password if requested!${NORMAL}\n" >&2;
  exit 1;
}

process_opts "$@"

TEMP_DIR=`mktemp -d`
main_msg_tmp=${TEMP_DIR}/install-linux.log
build_log=$BASE_PATH/build/install-linux.log
touch $build_log
touch $main_msg_tmp

if [ -f "$HOME/.mupel/mupel.conf" ];then
  . "$HOME/.mupel/mupel.conf";fi

# Install any missing applications that this script relies on. If these packages
# are already installed, don't force another "apt-get install". That would
# prevent them from being auto-removed, if they ever become eligible for that.
# And as this script only needs the packages once, there is no good reason to
# introduce a hard dependency on things such as dchroot and debootstrap.
packages=
for i in dchroot debootstrap libwww-perl; do
  [[ -d /usr/share/doc/"$i" ]] || packages="$packages $i";done

which schroot >/dev/null;
[ "$?" != "0" ] && packages="$packages schroot";

if  [[ ! -z $packages ]];then
{
  (
    touch ${TEMP_DIR}/build_active
    sudo -A -- apt-get -y install $packages
    err=$?; [ $err != 0 ] && showErrorDialog "Error on or near line ${LINENO}, Error code: $err" && exit_build 1
    rm -f ${TEMP_DIR}/build_active
  ) | sed -u "s/.*/# &/" >> ${main_msg_tmp} &
  pid=$!
  tail -f --pid=$pid ${main_msg_tmp} |
    showdialog --title="Update" --image="$BASE_PATH/icons/icon-install-128x128.png" --progress \
               --width=600 \
               --text="Install any missing applications" \
               --pulsate --enable-log --log-height=300 --button=gtk-cancel:1 \
               --auto-close > /dev/null
  ret=$?
  cat $main_msg_tmp >> $build_log
  echo "" > $main_msg_tmp
  if [[ $ret != 0 ]];then
  {
    showErrorDialog "Installation cancelled.\nExiting"
    ps -p $pid
    [[ $? = 0 ]] && killtree $pid KILL
    rm -f ${TEMP_DIR}/build_active
    exit_build 1
  }
  elif [ -f ${TEMP_DIR}/build_active ];then
  {
    showErrorDialog "Installation failed.\nExiting"
    rm -f ${TEMP_DIR}/build_active
    exit_build 1
  } fi
  unset pid;
} fi

# Create directory for chroot
[ ! -d /var/lib/chroot ] && sudo -A -- mkdir -p /var/lib/chroot

# Check which distributions are already installed
dist_installed=$(ls -r /var/lib/chroot/ | grep 64bit | sed 's/64bit//g' | tr '\n'  '!');
dist_installed=${dist_installed::-1};
dist_installed=$(echo ${dist_installed//$USE_LINUX_X86_DISTR/\^${USE_LINUX_X86_DISTR}});

# Find chroot environments that can be installed with debootstrap
dist_available="$(cd /usr/share/debootstrap/scripts
           ls -r | grep '^[a-z]*$')"

# Ask user to pick one of the available targets
for i in $(ls -r /var/lib/chroot/ | grep 64bit | sed 's/64bit//g'); do
{
  if `echo $dist_available | grep -q $i`;then
    dist_available=$(echo ${dist_available//$i/});fi
} done
dist_available=$(echo $dist_available | tr ' '  '!');
dist_available=${dist_available::-1};

if [[ -z $dist_installed ]];then
  way_selection="Install new distribution"
else
  way_selection="Update selected distribution\!Overwrite selected distribution\!Install new distribution\!Uninstall selected distribution"
fi

function parse_values
{
  local id=$1
  local value="$2"

  if [ $id = 4 ];then
  {
    if   [[ $value = "Update selected distribution|" ]];then
      echo "#> msg field 7:enable 1;"
      echo "#> msg field 10:enable 0;"
      echo "#> msg field 11:enable 0;"
      echo "#> msg field 13:enable 1;"
      echo "#> msg field 14:enable 1;"
      echo "#> msg field 15:enable 1;"
      echo "#> msg field 16:enable 1;"
      echo "#> msg field 17:enable 1;"
    elif [[ $value = "Overwrite selected distribution|" ]];then
      echo "#> msg field 7:enable 1;"
      echo "#> msg field 10:enable 0;"
      echo "#> msg field 11:enable 0;"
      echo "#> msg field 13:enable 1;"
      echo "#> msg field 14:enable 1;"
      echo "#> msg field 15:enable 1;"
      echo "#> msg field 16:enable 1;"
      echo "#> msg field 17:enable 1;"
    elif [[ $value = "Install new distribution|" ]];then
      echo "#> msg field 7:enable 0;"
      echo "#> msg field 10:enable 1;"
      echo "#> msg field 11:enable 1;"
      echo "#> msg field 13:enable 1;"
      echo "#> msg field 14:enable 1;"
      echo "#> msg field 15:enable 1;"
      echo "#> msg field 16:enable 1;"
      echo "#> msg field 17:enable 1;"
    elif [[ $value = "Uninstall selected distribution|" ]];then
      echo "#> msg field 7:enable 1;"
      echo "#> msg field 10:enable 0;"
      echo "#> msg field 11:enable 0;"
      echo "#> msg field 13:enable 0;"
      echo "#> msg field 14:enable 0;"
      echo "#> msg field 15:enable 0;"
      echo "#> msg field 16:enable 0;"
      echo "#> msg field 17:enable 0;"
    fi
  } fi
}

while :; do
{
  thread1_in=${TEMP_DIR}/thread1_in
  touch ${TEMP_DIR}/thread1_in
  install_values=$(
  (
    echo "#> msg field 10:enable 0;"
    echo "#> msg field 11:enable 0;"

    # Main loop
    while :;do
    {
      if [ ! -f "$thread1_in" ] ||
         [ -z `ps -h | grep "Linux system installer" | grep -v "grep" | awk -F ' ' '{print $1}'` ];then
        exit 0;fi
      proc=$(cat "$thread1_in")
      echo -n "" > "$thread1_in";
      IFS=$'\n';
      for line in ${proc}; do
      {
        if [[ "$line" == "#< msg"* ]];then
        {
          if [[ "$line" = *"field"* ]];then
          {
            IFS=$'\n'; for p in ${line}; do
              id=$(echo ${p} | awk -F ' ' '{print $4}' | awk -F ':' '{print $1}')
              value=$(echo ${p#*:} | awk -F ';' '{print $1}')
              IFS=$'|';
              if [[ "$id" -ge "0" ]];then
                parse_values $id "$value" >> "$thread1_in"
              else
                id2=0
                IFS=$'|';
                for value2 in ${value}; do
                {
                  parse_values $id2 "$value2" >> "$thread1_in"
                  ((id2++))
                } done;
              fi; IFS=$'\n';
            done; unset IFS;
          }
          else
          {
            echo "Wrong command! $line" > /dev/stderr
          } fi
        }
        else
        {
          echo "$line"
        } fi
      } done
      sleep 0.5;
    } done
  ) | \
  showdialog --form --title="Linux system installer" \
            --window-icon="$BASE_PATH/icons/icon-mupel-128x128.png" \
            --image="$BASE_PATH/icons/icon-kodi-mbe.png" \
            --xcom-log=$thread1_in \
            --field="<i><span size=\"large\">Ubuntu distribution system update / installation</span></i>:LBL" "" \
            --field=":LBL" "" \
            --field="\
   This script will help you through the process of installing
   a Debian or Ubuntu distribution in a chroot environment.

   You will have to provide your \"sudo\" password when
   requested.:LBL" "" \
            --field=":LBL" "" \
            --field="Select what you want to do:CB" "$way_selection" \
            --field=":LBL" "" \
            --field="<b>Reconfigure existing:</b>:LBL" "" \
            --field="Distribution:CB" "$dist_installed" \
            --field=":LBL" "" \
            --field="<b>Install new:</b>:LBL" "" \
            --field="Select which new distribution to install:CB" "$dist_available" \
            --field="Use as default?:CHK" "FALSE" \
            --field=":LBL" "" \
            --field="Would you like to add updates and security to the chroot's sources list:CHK" "TRUE" \
            --field="Include also 32 bit distribution:CHK" "TRUE" \
            --field="Include Kodi build depends (for build without use of ./tools/buildsteps):CHK" "TRUE" \
            --field="Use Kodi depends from team-xbmc 'devel' distribution:CHK" "FALSE" \
            --field="Include CEF build depends (without is CEF not supported):CHK" "TRUE" \
            --field=":LBL" "" \
            --field="\
   Copyright (C) 2015 Team KODI
   http://kodi.tv

   GNU General Public License, Version 3
   see http://www.gnu.org/licenses/:LBL" "" \
                              --field=":LBL" "" \
                              --field=":XTALK" '' \
                              --center 2> /dev/null);
  ret=$?
  rm -f "$thread1_in"
  if [ $ret != 0 ];then
  {
    showWarningDialog_YesNo "Are you sure to exit install?"
    [ $? = 0 ] && exit_build 1
  }
  else
    break;fi
} done

install_way="$(echo $install_values | awk -F '|' '{print $5}')"
udpate_dist="$(echo $install_values | awk -F '|' '{print $8}')"
install_dist="$(echo $install_values | awk -F '|' '{print $11}')"
install_as_default="$(echo $install_values | awk -F '|' '{print $12}')"
include_update="$(echo $install_values | awk -F '|' '{print $14}')"
include_32bit="$(echo $install_values | awk -F '|' '{print $15}')"
include_kodi_dep="$(echo $install_values | awk -F '|' '{print $16}')"
include_kodi_devel="$(echo $install_values | awk -F '|' '{print $17}')"
include_cef_dep="$(echo $install_values | awk -F '|' '{print $18}')"

if [ -f ${TEMP_DIR}/linux-install.failed ];then
 rm ${TEMP_DIR}/linux-install.failed;fi

# Error handler
trap '[ ! -z $pid ] && killtree $pid; killall -9 tail; evaluate_ret_error 1;' INT TERM QUIT HUP
trap 'sudo -A -- apt-get clean; tput bel; echo; echo Failed' EXIT

if [[ $install_way = "Update selected distribution" ]];then
{
  check_system_active "${udpate_dist}64bit";
  if [ $include_32bit = "TRUE" ];then
  {
    check_system_active "${udpate_dist}32bit";
    system_update       "${udpate_dist}" "32bit";
  } fi
  system_update       "${udpate_dist}" "64bit";

  # Let the user know what we did
  showdialog --title="Automatic build environment" \
             --image="$BASE_PATH/icons/icon-info-128x128.png" \
             --image-on-top --form \
             --button=gtk-ok:0 \
             --width=830 --show-uri --editable \
             --text-info \
             --text="<tt>
     <i><span size=\"large\">Successfully updated ${udpate_dist}</span></i>
_________________________________________________________________________________________

     The distribution $udpate_dist is updated which stored on
     <b>$([[ $include_32bit = TRUE ]] && echo "/usr/local/bin/${udpate_dist}32</b> and <b>")/usr/local/bin/${udpate_dist}64\"</b>.</tt>" 2> /dev/null

  [ $include_32bit = "TRUE" ] && LINUX_X86_32_INSTALLED=TRUE
  LINUX_X86_64_INSTALLED=TRUE
  saveConfigFile
}
elif [[ $install_way = "Overwrite selected distribution" ]];then
{
  showQuestionDialog "<b>\
Are you sure to overwrite \"<i>${udpate_dist}64bit(32bit)</i>\"?

Distribution becomes reseted to new.
</b>"
  [ $? != 0 ] && exit_build 1;

  check_system_active "${udpate_dist}64bit";
  if [ $include_32bit = "TRUE" ];then
  {
    check_system_active "${udpate_dist}32bit";
    system_overwrite    "${udpate_dist}" "32bit";
  } fi
  system_overwrite    "${udpate_dist}" "64bit";

  # Let the user know what we did
  showdialog --title="Automatic build environment" \
             --image="$BASE_PATH/icons/icon-info-128x128.png" \
             --image-on-top --form \
             --button=gtk-ok:0 \
             --width=830 --show-uri --editable \
             --text-info \
             --text="<tt>
     <i><span size=\"large\">Successfully overwrited ${udpate_dist}</span></i>
_________________________________________________________________________________________

     The distribution $udpate_dist overwrite is done which stored on
     <b>$([[ $include_32bit = TRUE ]] && echo "/usr/local/bin/${udpate_dist}32</b> and <b>")/usr/local/bin/${udpate_dist}64\"</b>.</tt>" 2> /dev/null

  [ $include_32bit = "TRUE" ] && LINUX_X86_32_INSTALLED=TRUE
  LINUX_X86_64_INSTALLED=TRUE
  saveConfigFile
}
elif [[ $install_way = "Install new distribution" ]];then
{
  check_system_active "${install_dist}64bit";
  if [ $include_32bit = "TRUE" ];then
  {
    check_system_active "${install_dist}32bit";
    system_install      "${install_dist}" "32bit";
  } fi
  system_install      "${install_dist}" "64bit";
  if [ $install_as_default = TRUE ] && [ -f "$HOME/.mupel/mupel.conf" ];then
  {
    loadConfigFile noOutLock:
    USE_LINUX_X86_DISTR=$install_dist
    saveConfigFile noInLock:
  } fi

  # Let the user know what we did
  if [ ! -f ${TEMP_DIR}/linux-install.failed ];then
  {
    showdialog --title="Automatic build environment" \
             --image="$BASE_PATH/icons/icon-info-128x128.png" \
             --image-on-top --form \
             --button=gtk-ok:0 \
             --width=830 --show-uri --editable \
             --text-info \
             --text="<tt>
     <i><span size=\"large\">Successfully installed ${install_dist}</span></i>
_________________________________________________________________________________________

     You can run programs inside of the chroot by invoking the
     <b>$([[ $include_32bit = TRUE ]] && echo "/usr/local/bin/${install_dist}32</b> or <b>")/usr/local/bin/${install_dist}64\"</b> command.

     This command can be used with arguments, in order to just run a single
     program inside of the chroot environment (e.g. \"${install_dist}64 make chrome\")
     or without arguments, in order to run an interactive shell session inside
     of the chroot environment.

     If you need to run things as \"root\", you can use \"sudo\" (e.g. try
     \"sudo ${install_dist}64 apt-get update\").

     Your home directory is shared between the host and the chroot. But I
     configured \"${HOME}/chroot\" to be private to the chroot environment.
     You can use it for files that need to differ between environments. This
     would be a good place to store binaries that you have built from your
     source files.

     For Chrome, this probably means you want to make your \"out\" directory a
     symbolic link that points somewhere inside of \"${HOME}/chroot\".

     You still need to run \"gclient runhooks\" whenever you switch from building
     outside of the chroot to inside of the chroot. But you will find that you
     don\'t have to repeatedly erase and then completely rebuild all your object
     and binary files.</tt>" 2> /dev/null
     [ $include_32bit = "TRUE" ] && LINUX_X86_32_INSTALLED=TRUE
     LINUX_X86_64_INSTALLED=TRUE
     saveConfigFile
  } fi
}
elif [[ $install_way = "Uninstall selected distribution" ]];then
{
  showQuestionDialog "<b>Are you sure to uninstall <i>$([[ $include_32bit = TRUE ]] && echo "${udpate_dist}32</i> and <i>")${udpate_dist}64</i>?</b>"
  [ $? != 0 ] && exit_build 1;

  (
    check_system_active "${udpate_dist}64bit"
    check_system_active "${udpate_dist}32bit"
    system_uninstall "${udpate_dist}32bit"
    system_uninstall "${udpate_dist}64bit"
  ) |
    showdialog --title="Install" --image="$BASE_PATH/icons/icon-install-128x128.png" --progress --width=600 \
               --text="Removing old distribution ${udpate_dist} ..." \
               --pulsate --log-height=300 --button=gtk-cancel:1 \
               --auto-close > /dev/null;

  # Let the user know what we did
  showdialog --title="Automatic build environment" \
             --image="$BASE_PATH/icons/icon-info-128x128.png" \
             --image-on-top --form \
             --button=gtk-ok:0 \
             --width=830 --show-uri --editable \
             --text-info \
             --text="<tt>
     <i><span size=\"large\">Successfully uninstalled ${udpate_dist}</span></i>
_________________________________________________________________________________________

     The distribution $udpate_dist is removed which was stored on
     <b>$([[ $include_32bit = TRUE ]] && echo "/usr/local/bin/${udpate_dist}32</b> and <b>")/usr/local/bin/${udpate_dist}64\"</b>.</tt>" 2> /dev/null
}
else
{
  showErrorDialog "<b>Undefined or unknown install way, exiting! </b>"
  exit_build 1
} fi

trap '' INT TERM QUIT HUP
trap '' EXIT

exit_build 0
